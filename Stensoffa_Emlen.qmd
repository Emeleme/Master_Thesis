---
title: "Emlen_Stensoffa"
author: "Maria Laura Mahecha Escobar"
format: pdf
editor: visual
---

## 

```{r}
#| output: FALSE 
setwd("E:/Users/mlmah/OneDrive/Documentos/MLME/Maestria/Animal_Ecology_2022_2024/Tesis/Database")
```

For running this script you need the following packages installed in your workspace:

```{r libraries, output=FALSE, include=TRUE, warning=FALSE}
library(usethis) #To use github
library(knitr) #to use markdown
library(circular) #to perform circular statistics
library(ggplot2) #to do beautiful plots
library(rmarkdown) #to use markdown
library(quarto) #to use markdown
library(lmerTest) #to do random effect tests
library(cowplot)
library(lme4) #to do random effect tests
library(dplyr) #managing tables and organizing data
library(janitor)
library(tvthemes)
library(phytools) #managing phylogenetic approaches
library(bpnreg) #circular regression models
library(CircStats) #some useful circular functions
library(RSQLite) #to connect database reades
library(data.table) #to handle tables
library(remotes)
library(tidyr)
library(readr)
library(CircStats)
library(performance)
library(tectonicr)
library(wesanderson)
library(fitdistrplus)
library(visreg)
library(emmeans)
```

## Emlen funnel analysis

Lets read the table with the Emlen data

```{r database}
#| output: false
#| include: false
stf_Emlen_IndData<-read.table("E:/Users/mlmah/OneDrive/Documentos/MLME/Maestria/Animal_Ecology_2022_2024/Tesis/Database/EmlenData_Autumn2023.txt", h=T, fill=T)
```

Let's change the names of the columns for the middle of the angles the sector has

```{r newSectorNames}
setnames(stf_Emlen_IndData, old=c("S1","S2","S3","S4","S5","S6","S7","S8","S9",
                              "S10","S11","S12","S13","S14","S15","S16","S17",
                              "S18","S19","S20","S21","S22","S23","S24"), 
         new = c("7.5","22.5","37.5","52.5","67.5","82.5","97.5","112.5",
                 "127.5","142.5","157.5","172.5","187.5","202.5","217.5",
                 "232.5","247.5","262.5","277.5","292.5","307.5","322.5",
                 "337.5","352.5"), skip_absent=TRUE)

```

To add an identification to every Emlen experiment, because there are more than one experiment per ring

```{r DirectionTable}
stf_Emlen_IndData<-tibble::rowid_to_column(stf_Emlen_IndData, "Identificator")
```

Let's define two functions that are going to be helpful handling circular data because there's functions that need the data input in degrees and others in radians. With this functions I can change it easily

```{r DegRad_Functions}
deg2rad <- function(deg) {(deg * pi) / (180)} #converts degrees to radians.
rad2deg <- function(rad) {(rad * 180) / (pi)} #converts radians to degrees.
```

Later Im gonna need to adjust some negative values and some values above 360 si I defined this function for it:

```{r adjust360_fun}
adjust_360 <- function(x) {
  if (is.numeric(x)) {
    x <- ifelse(!is.na(x) & x < 0, x + 360, x)
    x <- ifelse(!is.na(x) & x > 360, x - 360, x)
  }
  return(x)
}
```

This code makes the reppetition of the angles to a long format to being able to analyze the data after

```{r data_long}
stf_datalong_EmlenInd<-pivot_longer( #makes it a frequency to rep after
  stf_Emlen_IndData,
  cols=c("7.5","22.5","37.5","52.5","67.5","82.5","97.5","112.5",
                 "127.5","142.5","157.5","172.5","187.5","202.5","217.5",
                 "232.5","247.5","262.5","277.5","292.5","307.5","322.5",
                 "337.5","352.5"),
  names_to="sector",
  values_to="count")
```

We can make proportions out of the count data to plot it later

```{r count_prop}
stf_datalong_EmlenInd$sector<- as.numeric(stf_datalong_EmlenInd$sector)
stf_datalong_EmlenInd$count_prop<-stf_datalong_EmlenInd$count/stf_datalong_EmlenInd$TotalScratches
```

Lets save the all the numbers in one variable to make a new table with the

```{r uniqueIdent}
stf_uniqueValues_ID<-unique(stf_datalong_EmlenInd$Identificator)
```

This is a really important piece of code because I'm going to store the statistics results for each individual experiment of unimodal

```{r Results_unimodal}
#| warning: false
stf_results_df_unimodal <- data.frame(Identificator = stf_uniqueValues_ID,   #create an empty dataframe to store results
                         test_statistic = numeric(length(stf_uniqueValues_ID)),
                         p_value = numeric(length(stf_uniqueValues_ID)),
                         Mean = numeric(length(stf_uniqueValues_ID)),
                         rho = numeric(length(stf_uniqueValues_ID)),
                         Lower_CI = numeric(length(stf_uniqueValues_ID)),
                         Upper_CI = numeric(length(stf_uniqueValues_ID)))

# Loop through unique identifiers
for (i in stf_uniqueValues_ID) {
  subset_data <- subset(stf_datalong_EmlenInd, Identificator == i) #subsets data for each identificator/each entry in the database
  IndData <- as.data.frame(as.numeric(unlist(subset_data)))
  IndData <- na.omit(IndData)
  longdata <- as.numeric(rep(subset_data$sector, times = subset_data$count)) #repeats the degrees the times we counted already
  conf_interval <- confidence_interval(longdata, conf.level = 0.95, axial = FALSE)
  longdata <- deg2rad(longdata)  # Convert to radians
  rayleigh_test <- rayleigh.test(longdata)#performs rayleigh test for each entry in the database
  test_statistic <- rayleigh_test$statistic
  p_value <- rayleigh_test$p.value
  MeanDir<- mean.circular(longdata)
  rho_val <- rho.circular(longdata)
  
  
  # Convert the mean direction from radians to degrees and correct negative values
  MeanDir_deg <- rad2deg(MeanDir)  # Convert to degrees
  if (MeanDir_deg < 0) {
    MeanDir_deg <- 360 + MeanDir_deg  # Wrap around negative values
  }
  
  # Assign results to the correct rows
  row_index <- which(stf_results_df_unimodal$Identificator == i)
  stf_results_df_unimodal$test_statistic[row_index] <- test_statistic
  stf_results_df_unimodal$p_value[row_index] <- p_value
  stf_results_df_unimodal$Mean[row_index]<- MeanDir_deg
  stf_results_df_unimodal$rho[row_index]<-rho_val
  stf_results_df_unimodal$Lower_CI[row_index]<- conf_interval$conf.interval[1]
  stf_results_df_unimodal$Upper_CI[row_index]<- conf_interval$conf.interval[2]
}

```

And we need to do the same with for axial distribution

```{r Results_axial_ind}
#| warning: false

stf_results_df_axial <- data.frame(Identificator = stf_uniqueValues_ID,   #create an empty dataframe to store results
                         test_statistic = numeric(length(stf_uniqueValues_ID)),
                         p_value = numeric(length(stf_uniqueValues_ID)),
                         Mean = numeric(length(stf_uniqueValues_ID)),
                         rho = numeric(length(stf_uniqueValues_ID)),
                         Lower_CI = numeric(length(stf_uniqueValues_ID)),
                         Upper_CI = numeric(length(stf_uniqueValues_ID)))

# Loop through unique identifiers
for (i in stf_uniqueValues_ID) {
  subset_data <- subset(stf_datalong_EmlenInd, Identificator == i)
  IndData <- as.data.frame(as.numeric(unlist(subset_data)))
  IndData <- na.omit(IndData)
  longdata <- as.numeric(rep(subset_data$sector, times = subset_data$count))
  longdata <- longdata * 2
  conf_interval <- confidence_interval(longdata,
                                       conf.level = 0.95, axial = FALSE)
  lower_CI <- (conf_interval$conf.interval[1])/2
  upper_CI <- (conf_interval$conf.interval[2])/2
  longdata <- deg2rad(longdata)
  rayleigh_test <- rayleigh.test(longdata)
  test_statistic <- rayleigh_test$statistic
  p_value <- rayleigh_test$p.value
  MeanDir <- (mean.circular(longdata)) / 2
  rho_val <- rho.circular(longdata)
  
  # Convert the mean direction from radians to degrees and correct negative values
  MeanDir_deg <- rad2deg(MeanDir)  # Convert to degrees
  if (MeanDir_deg < 0) {
    MeanDir_deg <- 360 + MeanDir_deg  # Wrap around negative values
  }
  
  # Find closest sector value and corresponding count
  closest_sector <- subset_data$sector[
    which.min(abs(subset_data$sector - MeanDir_deg))]
  max_count <- max(subset_data$count[subset_data$sector == closest_sector])
  
  # Find closest sector value and corresponding count for MeanDir + 180
  closest_sector_p180 <- subset_data$sector[
    which.min(abs(subset_data$sector - (MeanDir_deg + 180)))]
  max_count_meanDir_p180 <- max(
    subset_data$count[subset_data$sector == closest_sector_p180])
  
  if (max_count < max_count_meanDir_p180) {
    MeanDir_deg <- MeanDir_deg + 180
    lower_CI <- lower_CI + 180
    upper_CI <- upper_CI + 180
  }
  
  # Assign results to the correct rows
  row_index <- which(stf_results_df_axial$Identificator == i)
  stf_results_df_axial$test_statistic[row_index] <- test_statistic
  stf_results_df_axial$p_value[row_index] <- p_value
  stf_results_df_axial$Mean[row_index] <- MeanDir_deg
  stf_results_df_axial$rho[row_index] <- rho_val
  stf_results_df_axial$Lower_CI[row_index] <- lower_CI
  stf_results_df_axial$Upper_CI[row_index] <- upper_CI
}




# 
# # Loop through unique identifiers
# for (i in stf_uniqueValues_ID) {
#   subset_data <- subset(stf_datalong_EmlenInd, Identificator == i) #subsets data for each identificator/each entry in the database
#   IndData <- as.data.frame(as.numeric(unlist(subset_data)))
#   IndData <- na.omit(IndData)
#   longdata <- as.numeric(rep(subset_data$sector, times = subset_data$count))#repeats the degrees the times we counted already
#   longdata <- longdata*2 #Double the angles to test for axial distribution
#   conf_interval <- confidence_interval(longdata, conf.level = 0.95, axial = FALSE)
#   longdata <- deg2rad(longdata)  # Convert to radians
#   rayleigh_test <- rayleigh.test(longdata)#performs rayleigh test for each entry in the database
#   test_statistic <- rayleigh_test$statistic
#   p_value <- rayleigh_test$p.value
#   MeanDir<- mean.circular(longdata)
#   rho_val <- rho.circular(longdata)
#   
#   
#   # Convert the mean direction from radians to degrees and correct negative values
#   MeanDir_deg <- rad2deg(MeanDir)  # Convert to degrees
#   if (MeanDir_deg < 0) {
#     MeanDir_deg <- 360 + MeanDir_deg  # Wrap around negative values
#   }
#   
#   # Assign results to the correct rows
#   row_index <- which(stf_results_df_axial$Identificator == i)
#   stf_results_df_axial$test_statistic[row_index] <- test_statistic
#   stf_results_df_axial$p_value[row_index] <- p_value
#   stf_results_df_axial$Mean[row_index]<- MeanDir_deg
#   stf_results_df_axial$rho[row_index]<-rho_val
#   stf_results_df_axial$Lower_CI[row_index]<- conf_interval$conf.interval[1]
#   stf_results_df_axial$Upper_CI[row_index]<- conf_interval$conf.interval[2]
# }
```

To combine the tables and to know which individuals have axial or unimodal

```{r stf_combined_df}
stf_combined_df <- bind_rows(stf_results_df_unimodal, 
                             stf_results_df_axial, .id = "Table")
```

And now

```{r stf_results_df}
stf_results_df <- stf_combined_df %>%
  group_by(Identificator) %>%
  slice(which.max(rho)) #Keep the values that are associated with the highest rho val
stf_results_df <- rename(stf_results_df, Distribution = Table) #Change the column name
stf_results_df$Distribution[stf_results_df$Distribution=="1"]<-"Unimodal"
stf_results_df$Distribution[stf_results_df$Distribution=="2"]<-"Axial"
length(stf_results_df$Distribution)
table(stf_results_df$Distribution) #to know how many birds have an axial distribution
```

Before merging anything, there are some negative values and some values above 360, we can adjust them with the function defined earlier:

```{r results360adj}
#| output: false
#| include: false
stf_results_df <- as.data.frame(stf_results_df %>% mutate_all(adjust_360))
```

We have the results per identificator. Now we merge both tables to have all the data associated to each one of the rings

```{r mergedEmlen}
stf_mergedEmlen<-merge(stf_results_df, stf_Emlen_IndData, by = "Identificator") #merge both dataframes by identificator
```

To check unique values and how many data points a ring has to perform a paired test later

```{r uniqueValues_Ring}
stf_uniqueValues_Ring<-unique(stf_mergedEmlen$Ring)
length(stf_uniqueValues_Ring)
```

We need to plot each individual as an rose diagram

```{r Ind_plot_hist}
#| warning: false
##ADD THE DISTRIBUTION OF EACH BIRD AND THE P-VALUE
ggplot(aes(x = sector, y = count), data = stf_datalong_EmlenInd)+
    coord_polar(theta = "x", direction = 1)+
    geom_bar(stat = "identity", fill = "maroon4", width = 14)+
    scale_x_continuous("", limits=c(0,360),
                      breaks=seq(0,360-0.001,by=45),
                      labels=c("N", "NE", "E", "SE", "S", "SW", "W", "NW")) +
    geom_segment(data=stf_mergedEmlen,
               mapping=aes(y = 0, x = Mean, xend = Mean, 
                           yend = (rho*max(stf_datalong_EmlenInd$count))),
                  arrow = arrow(type="closed",ends="last",length=unit(2,"mm")),
               color="black", size=0.7)+
    geom_vline(data=stf_mergedEmlen, aes(xintercept = Lower_CI), linetype="dashed")+
    geom_vline(data=stf_mergedEmlen, aes(xintercept = Upper_CI), linetype="dashed")+
    ggtitle("Circular Plot")+
    facet_grid(Ring~Experiment)+
    theme_minimal()

```

```{r PDF_ind}
# pdf("plot_ind_Species.pdf", onefile=TRUE)
# species_unique <- unique(datalong_EmlenInd$Species)
# for(i in species_unique) {
#   dat_count <- subset(datalong_EmlenInd, Species==species_unique[i])
#   dat_mean <- subset(mergedEmlen, Species==species_unique[i])
#   p1<-ggplot(aes(x = sector, y = count), data = dat_count)+
#     coord_polar(theta = "x", direction = 1)+
#     geom_bar(stat = "identity", fill = "maroon4", width = 14)+
#     scale_x_continuous("", limits=c(0,360),
#                       breaks=seq(0,360-0.001,by=45),
#                       labels=c("N", "NE", "E", "SE", "S", "SW", "W", "NW")) +
#     geom_segment(data=dat_mean,
#                mapping=aes(y = 0, x = Mean, xend = Mean, 
#                            yend = (test_statistic*max(dat_count$count))),
#                   arrow = arrow(type="closed",ends="last",length=unit(2,"mm")),
#                color="black", size=0.7)+
#     geom_vline(data=dat_mean, aes(xintercept = Lower_CI), linetype="dashed")+
#     geom_vline(data=dat_mean, aes(xintercept = Upper_CI), linetype="dashed")+
#     ggtitle("Circular Plot: ",i)+
#     facet_grid(Ring~Treatment)+
#     theme_minimal()
#   print(p1)
# }
# dev.off()

# pdf("plot_ind_Species.pdf", height=45, width=30, onefile=TRUE)
# datalong_EmlenInd<-as.data.frame(datalong_EmlenInd)
# species_unique <- as.vector(unique(datalong_EmlenInd$Species))
# for(i in 1:length(species_unique)) {
#   dat_count <- filter(datalong_EmlenInd, Species==species_unique[i])
#   dat_mean <- filter(mergedEmlen, Species==species_unique[i])
#   p1<-ggplot(aes(x = sector, y = count), data = dat_count)+
#     coord_polar(theta = "x", direction = 1)+
#     geom_bar(stat = "identity", fill = "maroon4", width = 14)+
#     scale_x_continuous("", limits=c(0,360),
#                       breaks=seq(0,360-0.001,by=45),
#                       labels=c("N", "NE", "E", "SE", "S", "SW", "W", "NW")) +
#     geom_segment(data=dat_mean,
#                mapping=aes(y = 0, x = Mean, xend = Mean, 
#                            yend = (test_statistic*max(dat_count$count))),
#                   arrow = arrow(type="closed",ends="last",length=unit(2,"mm")),
#                color="black", size=0.7)+
#     geom_vline(data=dat_mean, aes(xintercept = Lower_CI), linetype="dashed")+
#     geom_vline(data=dat_mean, aes(xintercept = Upper_CI), linetype="dashed")+
#     ggtitle("Circular Plot: ",i)+
#     facet_grid(Ring~Treatment)+
#     theme_minimal()
#   print(p1)
# }
# dev.off()
```

to see how many times a ring occours in the dataframe (this is because we need to have the same size if we want to do a paired test)

```{r occurrences}
stf_occurrences <- stf_mergedEmlen %>% count(Ring) 
print(stf_occurrences)
```

I need to know which ones have less than 0.05 of p-value

```{r}
stf_less_alpha<-subset(stf_mergedEmlen, p_value>0.05)
length(stf_less_alpha$Identificator)
```

To delete the indentificators that don't have a significant p-value for Rayleigh test

```{r}
stf_mergedEmlen <- subset(stf_mergedEmlen, p_value<0.05)
```

Now we can choose the columns to make the tests

```{r EmlenData_ForTest}
stf_EmlenData_ForTest<- dplyr::select(stf_mergedEmlen, c("Identificator", "Distribution",
                                                 "rho","p_value", 
                                                 "Mean", "Lower_CI", "Upper_CI",
                                                 "Species", "Treatment","Ring",
                                                 "BreedingDistribution",
                                                 "Experiment"))
```

```{r set_y}
stf_EmlenData_ForTest$y<-0.95
```

And now divide them for treatment

```{r TreatmentSplit}
stf_Emlen_control<-filter(stf_EmlenData_ForTest, Treatment=="Control") #just control
stf_Emlen_treatment<-filter(stf_EmlenData_ForTest, Treatment=="Treatment") #just 24h treatment
stf_Emlen_pre<-filter(stf_EmlenData_ForTest, Experiment=="1Pre")
stf_Emlen_post<-filter(stf_EmlenData_ForTest, Experiment=="2Post")
```

Plot the mean of all individuals in the treatments

```{r simple_plots}
#| warning: false
plot(as.circular(stf_Emlen_control$Mean, type="angles", units="degrees", template="geographic", zero=0))
stf_r_con <- rho.circular(stf_Emlen_control$Mean, na.rm = FALSE)
arrows.circular(mean.circular(stf_Emlen_control$Mean), y=stf_r_con, length=0.1)

plot(as.circular(stf_Emlen_treatment$Mean, type="angles", units="degrees", template="geographic", zero=0))
stf_r_tre <- rho.circular(stf_Emlen_treatment$Mean, na.rm = FALSE)
arrows.circular(mean.circular(stf_Emlen_treatment$Mean), y=stf_r_tre, length=0.1)

```

To calculate the mean for each species we can do the same as we did before for each individual but with other method. Here we did it also for unimodal and axial distribution

```{r Results_treat}
#| warning: false
#| output: false
#| include: false

stf_EmlenData_sp_Mean<- dplyr::select(stf_mergedEmlen, c("Identificator",
                                                 "Mean", "Species", "Treatment"
                                                 ,"Ring","BreedingDistribution",
                                                 "Experiment"))
#Unimodal spp
stf_Results_treat_all_unimodal <- stf_EmlenData_sp_Mean %>%
  group_by(Treatment, Experiment) %>%
  summarize(
    N=length(Mean),
    Lower_CI = if (n() > 1) confidence_interval(Mean, conf.level = 0.95,
                                                axial = FALSE)$conf.interval[1] 
    else NA,
    Upper_CI = if (n() > 1) confidence_interval(Mean, conf.level = 0.95,
                                                axial = FALSE)$conf.interval[2]
    else NA,
    test_statistic = rayleigh_test(deg2rad(Mean))$statistic,
    p_value = rayleigh_test(deg2rad(Mean))$p.value,
    Mean_avg = rad2deg(mean.circular(deg2rad(Mean))),
    rho_val = rho.circular(deg2rad(Mean))
  )

#Axial per spp
stf_Results_treat_all_axial <- stf_EmlenData_sp_Mean %>%
  group_by(Treatment, Experiment) %>%
  summarize(
    N=length(Mean),
    Lower_CI = if (n() > 1) confidence_interval((Mean*2), conf.level = 0.95,
                                                axial = TRUE)$conf.interval[1] 
    else NA,
    Upper_CI = if (n() > 1) confidence_interval((Mean*2), conf.level = 0.95,
                                                axial = TRUE)$conf.interval[2]
    else NA,
    test_statistic = rayleigh_test(deg2rad(Mean*2))$statistic,
    p_value = rayleigh_test(deg2rad(Mean*2))$p.value,
    Mean_avg = rad2deg(mean.circular(deg2rad(Mean*2))),
    rho_val = rho.circular(deg2rad(Mean*2))
  )

# View(Results_treat_all)


# EmlenData_sp_Mean<- dplyr::select(mergedEmlen, c("Identificator",
#                                                  "Mean", "Species", "Treatment","Ring",
#                                                  "BreedingDistribution", "Week"))
# Results_treat <- EmlenData_sp_Mean %>%
#   group_by(Treatment, Species) %>%
#   summarize(
#     Lower_CI = if (n() > 1) confidence_interval(Mean, conf.level = 0.95, axial = FALSE)$conf.interval[1] else NA,
#     Upper_CI = if (n() > 1) confidence_interval(Mean, conf.level = 0.95, axial = FALSE)$conf.interval[2] else NA,
#     test_statistic = rayleigh_test(deg2rad(Mean))$statistic,
#     p_value = rayleigh_test(deg2rad(Mean))$p.value,
#     Mean = rad2deg(mean.circular(deg2rad(Mean)))
#   )
# 
# View(Results_treat)

```

To get if its axial or unimodal the species

```{r}
stf_combined_df_all <- bind_rows(stf_Results_treat_all_unimodal, stf_Results_treat_all_axial, .id = "Table")
stf_Results_treat_all <- stf_combined_df_all %>%
  group_by(Treatment, Experiment) %>%
  slice(which.max(rho_val)) #Keep the values that are associated with the highest rho val
stf_Results_treat_all <- rename(stf_Results_treat_all, Distribution = Table) #Change the column name
stf_Results_treat_all$Distribution[stf_Results_treat_all$Distribution=="1"]<-"Unimodal"
stf_Results_treat_all$Distribution[stf_Results_treat_all$Distribution=="2"]<-"Axial"
length(stf_Results_treat_all$Distribution)
table(stf_Results_treat_all$Distribution) #to know how many birds have an axial distribution
```

To make the negative values positive, I added 360. The values that are above 360 I substracted 360

```{r res_treatAdj}
#| warning: false
# Convert values outside scope to 360 modul
stf_Results_treat <- as.data.frame(stf_Results_treat_all %>% mutate_all(adjust_360)) 
#Keep only > 0.05values
stf_Results_treat <- subset(stf_Results_treat,
                               p_value < 0.05)
stf_Results_treat <- stf_Results_treat %>% 
       rename("Mean" = "Mean_avg")
```

To plot each species per treatment with the mean value for the species and the confidence intervals for each species

```{r AllInd_sp}
#Plot individuals that meet the criteria
ggplot(aes(x = Mean, y=y, colour=Species), data=stf_EmlenData_ForTest) +
  geom_point(size = 1.8, alpha=0.5, shape=21, stroke = 0.5, colour = "black",
             aes(fill=factor(Treatment)))+
  coord_polar() +
  scale_x_continuous("", limits=c(0,360),
                      breaks=seq(0,360-0.001,by=90),
                      labels=c("N","E","S","W")) +
  scale_y_continuous("",limits=c(0,1), breaks=1)+
  geom_hline(yintercept=1)+
  #theme_minimal()+
  geom_segment(data=stf_Results_treat, 
               mapping=aes(y = 0, xend = Mean, yend = rho_val),
                  arrow = arrow(type="closed",ends="last",length=unit(2,"mm")),
               color="black", size=0.7)+
  geom_vline(data=stf_Results_treat, aes(xintercept = Lower_CI), linetype="dashed")+
  geom_vline(data=stf_Results_treat, aes(xintercept = Upper_CI), linetype="dashed")+
  theme(panel.background = element_rect(fill = NA),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())+
  ggtitle("Circular Plot") +  
  ylab("")+ 
  xlab("")+
  facet_wrap(Treatment~Experiment)
```

Make the pre all into one group

```{r}
stf_Emlen_pre<-filter(stf_EmlenData_ForTest, Experiment=="1Pre")

stf_Emlen_pre_Mean<- dplyr::select(stf_Emlen_pre, c("Identificator",
                                                 "Mean", "Species", "Treatment"
                                                 ,"Ring","BreedingDistribution",
                                                 "Experiment"))
#Unimodal spp
stf_Results_treat_pre_unimodal <- stf_Emlen_pre_Mean %>%
  group_by(Experiment) %>%
  summarize(
    N=length(Mean),
    Lower_CI = if (n() > 1) confidence_interval(Mean, conf.level = 0.95,
                                                axial = FALSE)$conf.interval[1] 
    else NA,
    Upper_CI = if (n() > 1) confidence_interval(Mean, conf.level = 0.95,
                                                axial = FALSE)$conf.interval[2]
    else NA,
    test_statistic = rayleigh_test(deg2rad(Mean))$statistic,
    p_value = rayleigh_test(deg2rad(Mean))$p.value,
    Mean_avg = rad2deg(mean.circular(deg2rad(Mean))),
    rho_val = rho.circular(deg2rad(Mean))
  )

#Axial per spp
stf_Results_treat_pre_axial <- stf_Emlen_pre_Mean %>%
  group_by(Experiment) %>%
  summarize(
    N=length(Mean),
    Lower_CI = if (n() > 1) confidence_interval((Mean*2), conf.level = 0.95,
                                                axial = TRUE)$conf.interval[1] 
    else NA,
    Upper_CI = if (n() > 1) confidence_interval((Mean*2), conf.level = 0.95,
                                                axial = TRUE)$conf.interval[2]
    else NA,
    test_statistic = rayleigh_test(deg2rad(Mean*2))$statistic,
    p_value = rayleigh_test(deg2rad(Mean*2))$p.value,
    Mean_avg = rad2deg(mean.circular(deg2rad(Mean*2))),
    rho_val = rho.circular(deg2rad(Mean*2))
  )
```

To plot all pre together

```{r plot_PrePost}
stf_Results_treat_pre_unimodal<- as.data.frame(stf_Results_treat_pre_unimodal)
stf_Results_treat_pre_unimodal$Mean_avg<- as.numeric(stf_Results_treat_pre_unimodal$Mean_avg)
stf_Results_treat_pre_unimodal <- stf_Results_treat_pre_unimodal %>% 
       rename("Mean" = "Mean_avg")

#Plot individuals that meet the criteria
ggplot(aes(x = Mean, y=y, colour=Species), data=stf_Emlen_pre) +
  geom_point(size = 1.8, alpha=0.5, shape=21, stroke = 0.5, colour = "black",
             aes(fill=factor(Treatment)))+
  coord_polar() +
  scale_x_continuous("", limits=c(0,360),
                      breaks=seq(0,360-0.001,by=90),
                      labels=c("N","E","S","W")) +
  scale_y_continuous("",limits=c(0,1), breaks=1)+
  geom_hline(yintercept=1)+
  #theme_minimal()+
  geom_segment(data=stf_Results_treat_pre_unimodal, 
               mapping=aes(y = 0, xend = Mean, yend = rho_val),
                  arrow = arrow(type="closed",ends="last",
                                length=unit(2,"mm")),
               color="black", size=0.7)+
  geom_vline(data=stf_Results_treat_pre_unimodal, aes(xintercept = Lower_CI),
             linetype="dashed")+
  geom_vline(data=stf_Results_treat_pre_unimodal, aes(xintercept = Upper_CI),
             linetype="dashed")+
  theme(panel.background = element_rect(fill = NA),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())+
  ggtitle("Circular Plot") +  
  ylab("")+ 
  xlab("")
#  facet_wrap(vars(Experiment))
```

To plot each individual ring witht the mean value and the confidence intervals

```{r AllInds}
# ggplot(aes(x = Mean, y=y, colour=Species), data=EmlenData_ForTest) +
#   geom_point(size = 3, alpha=1/2)+
#   coord_polar() +
#   scale_x_continuous("", limits=c(0,360),
#                       breaks=seq(0,360-0.001,by=90),
#                       labels=c("N","E","S","W")) +
#          scale_y_continuous("",limits=c(0,1), breaks=1)+
#   geom_hline(yintercept=1)+
#   theme(panel.background = element_rect(fill = NA),
#         axis.title.y = element_blank(),
#         axis.text.y = element_blank(),
#         axis.ticks.y = element_blank())+
#   ggtitle("Circular Plot") +  
#   ylab("")+ 
#   xlab("")+
#   facet_wrap(vars(Ring))
# 
# 
# ggplot(aes(x = Mean, y=y, colour=Species), data=EmlenData_ForTest) +
#   geom_point(size = 1.8, alpha=1, shape=21, stroke = 0.5, colour = "black", 
#              aes(fill=factor(Species)))+
#   coord_polar() +
#   scale_x_continuous("", limits=c(0,360),
#                       breaks=seq(0,360-0.001,by=90),
#                       labels=c("N","E","S","W")) +
#          scale_y_continuous("",limits=c(0,1), breaks=1)+
#   geom_hline(yintercept=1)+
#   #theme_minimal()+
#   geom_segment(data=results_df, 
#                mapping=aes(y = 0, xend = Mean, yend = test_statistic),
#                   arrow = arrow(type="closed",ends="last",length=unit(2,"mm")), color="black", size=0.7)+
#   geom_vline(data=results_df, aes(xintercept = Lower_CI))+
#   geom_vline(data=results_df, aes(xintercept = Upper_CI))+
#   theme(panel.background = element_rect(fill = NA),
#         axis.title.y = element_blank(),
#         axis.text.y = element_blank(),
#         axis.ticks.y = element_blank())+
#   ggtitle("Circular Plot") +  
#   ylab("")+ 
#   xlab("")+
#   facet_wrap(vars(Ring))
```

### Tests

First lets make a subset for each treatment and change the column names to something distinguishable

```{r treat_subset}
stf_Emlen_pre <- stf_Emlen_pre %>%   
  dplyr::select(-c("Experiment", "Identificator")) %>%   
  setnames(old = c("rho", "p_value", "Mean",    
                   "Lower_CI", "Upper_CI"),        
           new = c("rho_pre", "p_value_pre", "Mean_pre",       
                   "Lower_CI_pre", "Upper_CI_pre"),        
           skip_absent = TRUE)  
stf_Emlen_post <- stf_Emlen_post %>% 
  dplyr::select(-c("Experiment", "Identificator", "Species",   
                   "BreedingDistribution", "y")) %>%  
  setnames(old = c("rho", "p_value", "Mean",        
                   "Lower_CI", "Upper_CI", "Treatment"),        
           new = c("rho_post", "p_value_post",        
                   "Mean_post", "Lower_CI_post", "Upper_CI_post", "Treatment_post"),     
           skip_absent = TRUE)
```

#### Watson test

To test whether the mean values for each group differ between groups we can do a watson test. R help documentation says:\
Watson.williams.test assumptions are that: (1) the samples are drawn from populations with a von Mises distribution; (2) the parameter of concentration has the same value in all populations; (3) this parameter is sufficiently large (i.e. \> 1).

If the assumptions are not met in the data set it is needed to do a watson.wheeler.test

```{r Watson_Wheeler}
#| warning: false
stf_EmlenData_ForTest$Mean<-as.circular(stf_EmlenData_ForTest$Mean, 
                                        units='degrees', template='geographics',
                                        modulo="2pi")

watson.wheeler.test(Mean ~ Treatment, stf_EmlenData_ForTest, na.omit())
watson.wheeler.test(Mean ~ Experiment, stf_EmlenData_ForTest, na.omit())
```

Now we can also make a Watson test for the pre-experiment and post-experiment between control and treatment

```{r}
#| warning: false
stf_Emlen_pre$Mean_pre<-as.circular(stf_Emlen_pre$Mean_pre, 
                                        units='degrees', template='geographics',
                                        modulo="2pi")
stf_Emlen_post$Mean_post<-as.circular(stf_Emlen_post$Mean_post, 
                                        units='degrees', template='geographics',
                                        modulo="2pi")

watson.wheeler.test(Mean_pre ~ Treatment, stf_Emlen_pre, na.omit())
watson.wheeler.test(Mean_post ~ Treatment_post, stf_Emlen_post, na.omit())
```

#### Hotelling paired test

Now we can intersect all of the rings and make a table suitable for the hotelling test

```{r common_ids}
stf_common_ids <- Reduce(intersect, list(stf_Emlen_pre$Ring, stf_Emlen_post$Ring))
```

To retrieve the Rings that have capture, control and treatment experiments

```{r Emlen_ID}
stf_Emlen_pre_ID <- stf_Emlen_pre[stf_Emlen_pre$Ring %in% stf_common_ids, ]
stf_Emlen_post_ID <- stf_Emlen_post[stf_Emlen_post$Ring %in% stf_common_ids, ]
```

And to merge a database for making the Hotelling test

```{r hotelling_db}
stf_Emlen_hotelling <- merge(stf_Emlen_pre_ID, stf_Emlen_post_ID, by="Ring")
```

Now we run three paired hotelling test because I dont found how else do it

```{r paired_hotelling}
source("https://raw.githubusercontent.com/olitroski/circular/master/paired.hotelling.r") #para correr el hotelling test. p.value<0.05 there are differences between the mean in the samples
paired.hotelling(stf_Emlen_hotelling$Mean_pre, stf_Emlen_hotelling$Mean_post)
```

And Hotelling for the Willys and Robins

```{r}
Emlen_hotelling_C <- subset(stf_Emlen_hotelling, Treatment =="Control")
Emlen_hotelling_T <- subset(stf_Emlen_hotelling, Treatment =="Treatment")
```

The test for Willys

```{r}
paired.hotelling(Emlen_hotelling_C$Mean_pre, Emlen_hotelling_C$Mean_post)
paired.hotelling(Emlen_hotelling_T$Mean_pre, Emlen_hotelling_T$Mean_post)
```

plot the difference

#### Angular difference

How much is the angular change between the two means that are different (capture and control; control and treatment)? For this I just going to make a substraction between means and plot the difference to see if they change to a similar degree. Values that are higher than 360 are adjust and values that are below 0 are adjust with the function previously described adjust_360

First plot the difference

```{r}
plot(Emlen_hotelling_C$Mean_pre,Emlen_hotelling_C$Mean_post,
     xlim = c(0, 360),
     ylim = c(0, 360))
abline(coef = c(0,1))

plot(Emlen_hotelling_T$Mean_pre,Emlen_hotelling_T$Mean_post,
     xlim = c(0, 360),
     ylim = c(0, 360))
abline(coef = c(0,1))
```

Calculate the angular difference. Porsitive values mean that the post experiment has greater values than the pre experiment, which could mean that the

```{r Angular_diff}
stf_Emlen_hotelling$Angular_diff <- (stf_Emlen_hotelling$Mean_post-stf_Emlen_hotelling$Mean_pre)
```

And now we can make a little plot with this information to see if all the individuals are changing in the same degree the orientation across groups

CALCULATE MEAN FOR ALL AND THE RHO AND CI TO PLOT THEM HERE TOO

```{r Angular_plot}
plot(stf_Emlen_hotelling$Angular_diff)
abline(h=0)
```

Plot the angles in the same figure

```{r}
ggplot(aes(x = Mean, y=y, colour=Experiment), data=stf_EmlenData_ForTest) +
  geom_point(size = 1.8, alpha=0.5, shape=21, stroke = 0.5, colour = "black",
             aes(fill=factor(Experiment)))+
  coord_polar() +
  scale_x_continuous("", limits=c(0,360),
                      breaks=seq(0,360-0.001,by=90),
                      labels=c("N","E","S","W")) +
  scale_y_continuous("",limits=c(0,1), breaks=1)+
  geom_hline(yintercept=1)+
  #theme_minimal()+
  geom_segment(data=stf_Results_treat, 
               mapping=aes(y = 0, xend = Mean, yend = rho_val, colour=Experiment),
                  arrow = arrow(type="closed",ends="last",length=unit(2,"mm")),
               #color="black", 
               size=0.7)+
  geom_vline(data=stf_Results_treat, aes(xintercept = Lower_CI, colour=Experiment), 
             linetype="dashed")+
  geom_vline(data=stf_Results_treat, aes(xintercept = Upper_CI, colour=Experiment), 
             linetype="dashed")+
  theme(panel.background = element_rect(fill = NA),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())+
  ggtitle("Circular Plot") +  
  ylab("")+ 
  xlab("")+
  facet_wrap(vars(Treatment))
```

#### GLMER

We saw that for the means of means there's a difference between the control and treatment and between control and capture. But these approaches only uses the means, to model all the points in the emlen funnel experiments we can use glmer as follows.

First I need to convert the sector numbers in radians to being able to calculate the sin and cos for each one of them

```{r Emlen_glmer}
stf_Emlen_glmer<- as.data.frame(stf_datalong_EmlenInd)
stf_Emlen_glmer$sector<- as.numeric(stf_Emlen_glmer$sector)
stf_Emlen_glmer$radians <- deg2rad(stf_Emlen_glmer$sector)

# Emlen_glmer <- Emlen_glmer %>%
#   uncount(weights = count)
```

Then, to calculate the distribution of the counts vector we can use:

```{r counts_dist}
#descdist(Emlen_glmer$sector,  discrete = FALSE)
descdist(stf_Emlen_glmer$count,  discrete = FALSE)
```

```{r}
hist(stf_Emlen_glmer$count)
```

And now the models

```{r}
stf_Emlen_lmer_Ring <- glmer(count ~ sin(radians) + cos(radians) + (1|Ring),
                             data = stf_Emlen_glmer,
                         na.action = 'na.fail', family="poisson")
summary(stf_Emlen_lmer_Ring)
check_model(stf_Emlen_lmer_Ring)
plot(DHARMa::simulateResiduals(stf_Emlen_lmer_Ring)) 
fam.pez <- family(stf_Emlen_lmer_Ring)

FUN_RevTrans_pez <- function(x){
  return(fam.pez$linkinv(x)) 
}
visreg(stf_Emlen_lmer_Ring, "radians", trans = FUN_RevTrans_pez)

gr <- emmeans::ref_grid(stf_Emlen_lmer_Ring, cov.keep= c('radians'))
emm_DS <- emmeans::emmeans(gr, spec= c('radians'), level= 0.95)
emm_DS_DF <- as.data.frame(emm_DS)

ggplot() +
  #coord_polar()+
  geom_point(data=stf_Emlen_glmer, aes(x=rad2deg(radians), y=count),alpha=0.35,
                          colour="lightblue")+
  geom_ribbon(data= data.frame(emm_DS), 
              aes(x = rad2deg(radians), ymin= FUN_RevTrans_pez(asymp.LCL), 
                  ymax= FUN_RevTrans_pez(asymp.UCL), y= NULL),
              alpha=0.5, fill= 'grey80') +
  geom_line(data = data.frame(emm_DS), 
            aes(x = rad2deg(radians), y = FUN_RevTrans_pez(emmean)), linewidth = 1)

#emmeans(Emlen_lmer_Ring, list(pairwise ~ radians), adjust="tukey")

```

model comparison

```{r}
null_stf_Emlen_lmer_Ring <- glmer(count ~ 1 + (1|Ring),
                             data = stf_Emlen_glmer,
                         na.action = 'na.fail', family="poisson")

anova(stf_Emlen_lmer_Ring, null_stf_Emlen_lmer_Ring, test="LTR")
```

model performance

```{r}
model_performance(stf_Emlen_lmer_Ring)
```

second

```{r}
stf_Emlen_lmer_Experiment <- glmer(count ~ sin(radians)*Experiment + 
                           cos(radians)*Experiment + (1|Ring), 
                           data = stf_Emlen_glmer,
                           na.action = 'na.fail', family="poisson")
summary(stf_Emlen_lmer_Experiment)
check_model(stf_Emlen_lmer_Experiment)
plot(DHARMa::simulateResiduals(stf_Emlen_lmer_Experiment)) 
fam.pez <- family(stf_Emlen_lmer_Experiment)

visreg(stf_Emlen_lmer_Experiment, "radians", by='Experiment', 
       trans = FUN_RevTrans_pez)

gr <- emmeans::ref_grid(stf_Emlen_lmer_Experiment, 
                        cov.keep= c('radians', 'Experiment'))
emm_DS <- emmeans::emmeans(gr, spec= c('radians', 'Experiment'),
                           level= 0.95)
emm_DS_DF <- as.data.frame(emm_DS)

ggplot() +
  #coord_polar()+
  geom_point(data=stf_Emlen_glmer, aes(x=radians, y=count, colour=Treatment),
             alpha=0.3)+
  geom_ribbon(data= data.frame(emm_DS), 
              aes(x = radians, ymin= FUN_RevTrans_pez(asymp.LCL), 
                  ymax= FUN_RevTrans_pez(asymp.UCL), y= NULL),
              alpha=0.5, fill= 'grey80') +
  geom_line(data = data.frame(emm_DS), 
            aes(x = radians, y = FUN_RevTrans_pez(emmean)), linewidth = 1)+
  facet_wrap(vars(Experiment))

emmeans(stf_Emlen_lmer_Experiment, list(pairwise ~ radians:Experiment), 
        adjust="tukey")
```

model comparison

```{r}
anova(stf_Emlen_lmer_Ring, null_stf_Emlen_lmer_Ring, stf_Emlen_lmer_Experiment,
      test="LTR")
```

model performance

```{r}
model_performance(stf_Emlen_lmer_Experiment)
```

third

```{r}
stf_Emlen_lmer_ExperimentTreatment <- 
  glmer(count ~ sin(radians)*Experiment*Treatment + 
          cos(radians)*Experiment*Treatment + (1|Ring),
        data = stf_Emlen_glmer, 
        na.action = 'na.fail', family="poisson")
summary(stf_Emlen_lmer_ExperimentTreatment)
check_model(stf_Emlen_lmer_ExperimentTreatment)
plot(DHARMa::simulateResiduals(stf_Emlen_lmer_ExperimentTreatment)) 
fam.pez <- family(stf_Emlen_lmer_ExperimentTreatment)

# visreg(stf_Emlen_lmer_ExperimentTreatment, "radians", by=
#          c('Treatment','Experiment'), trans = FUN_RevTrans_pez)

gr <- emmeans::ref_grid(stf_Emlen_lmer_ExperimentTreatment, cov.keep= 
                          c('radians', 'Treatment', 'Experiment'))
emm_DS <- emmeans::emmeans(gr, spec= c('radians', 'Treatment', 'Experiment'), 
                           level= 0.95)
emm_DS_DF <- as.data.frame(emm_DS)

ggplot() +
  #coord_polar()+
  geom_point(data=stf_Emlen_glmer, aes(x=radians, y=count, colour=Treatment),
             alpha=0.35)+
  geom_ribbon(data= data.frame(emm_DS),
              aes(x = radians, ymin= FUN_RevTrans_pez(asymp.LCL),
                  ymax= FUN_RevTrans_pez(asymp.UCL), y= NULL, 
                  colour=Treatment),
              alpha=0.5, fill= 'grey80') +
  geom_line(data = data.frame(emm_DS),
            aes(x = radians, y = FUN_RevTrans_pez(emmean), 
                colour=Treatment), linewidth = 1)+
  facet_wrap(vars(Experiment))

emmeans(stf_Emlen_lmer_ExperimentTreatment, 
        list(pairwise ~ radians:Treatment*Experiment), adjust="tukey")
```

model comparison

```{r}
anova(stf_Emlen_lmer_Ring, null_stf_Emlen_lmer_Ring, stf_Emlen_lmer_Experiment,
      stf_Emlen_lmer_ExperimentTreatment, test="LTR")
```

model performance

```{r}
model_performance(stf_Emlen_lmer_ExperimentTreatment)
```

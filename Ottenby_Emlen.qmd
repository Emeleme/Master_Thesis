---
title: "Emlen_Ottenby"
author: "Maria Laura Mahecha Escobar"
format: pdf
editor: visual
---

## 

```{r}
#| output: FALSE 
setwd("E:/Users/mlmah/OneDrive/Documentos/MLME/Maestria/Animal_Ecology_2022_2024/Tesis/Database")
```

For running this script you need the following packages installed in your workspace:

```{r libraries, output=FALSE, include=TRUE, warning=FALSE}
library(usethis) #To use github
library(knitr) #to use markdown
library(circular) #to perform circular statistics
library(ggplot2) #to do beautiful plots
library(rmarkdown) #to use markdown
library(quarto) #to use markdown
library(lmerTest) #to do random effect tests
library(cowplot)
library(lme4) #to do random effect tests
library(dplyr) #managing tables and organizing data
library(janitor)
library(tvthemes)
library(phytools) #managing phylogenetic approaches
library(bpnreg) #circular regression models
library(CircStats) #some useful circular functions
library(RSQLite) #to connect database reades
library(data.table) #to handle tables
library(remotes)
library(tidyr)
library(readr)
library(CircStats)
library(performance)
library(tectonicr)
library(wesanderson)
```

## Emlen funnel analysis

Lets read the table with the Emlen data

```{r database}
#| output: false
#| include: false
Emlen_IndData<-read.table("E:/Users/mlmah/OneDrive/Documentos/MLME/Maestria/Animal_Ecology_2022_2024/Tesis/Database/EmlenData_Spring2023.txt", h=T)
```

Let's change the names of the columns for the middle of the angles the sector has

```{r newSectorNames}
setnames(Emlen_IndData, old=c("S1","S2","S3","S4","S5","S6","S7","S8","S9",
                              "S10","S11","S12","S13","S14","S15","S16","S17",
                              "S18","S19","S20","S21","S22","S23","S24"), 
         new = c("7.5","22.5","37.5","52.5","67.5","82.5","97.5","112.5",
                 "127.5","142.5","157.5","172.5","187.5","202.5","217.5",
                 "232.5","247.5","262.5","277.5","292.5","307.5","322.5",
                 "337.5","352.5"), skip_absent=TRUE)

```

To add an identification to every Emlen experiment, because there are more than one experiment per ring

```{r DirectionTable}
Emlen_IndData<-tibble::rowid_to_column(Emlen_IndData, "Identificator")
```

Let's define two functions that are going to be helpful handling circular data because there's functions that need the data input in degrees and others in radians. With this functions I can change it easily

```{r DegRad_Functions}
deg2rad <- function(deg) {(deg * pi) / (180)} #converts degrees to radians.
rad2deg <- function(rad) {(rad * 180) / (pi)} #converts radians to degrees.
```

Later Im gonna need to adjust some negative values and some values above 360 si I defined this function for it:

```{r adjust360_fun}
adjust_360 <- function(x) {
  if (is.numeric(x)) {
    x <- ifelse(!is.na(x) & x < 0, x + 360, x)
    x <- ifelse(!is.na(x) & x > 360, x - 360, x)
  }
  return(x)
}
```

Now, lets organize the dates in the table

```{r Weeks}
Emlen_IndData$Date<-lubridate::dmy(Emlen_IndData$Date)
Emlen_IndData <- Emlen_IndData %>%
  mutate(Week = case_when(
    between(Date, as.Date("2023-04-20"), as.Date("2023-04-26")) ~ 1,
    between(Date, as.Date("2023-04-28"), as.Date("2023-05-04")) ~ 2,
    between(Date, as.Date("2023-05-08"), as.Date("2023-05-14")) ~ 3,
    between(Date, as.Date("2023-05-16"), as.Date("2023-05-22")) ~ 4,
    between(Date, as.Date("2023-05-25"), as.Date("2023-05-31")) ~ 5,
    TRUE ~ 6 # Defining values for each week with date intervals
  ))
```

This code makes the reppetition of the angles to a long format to being able to analyze the data after

```{r data_long}
datalong_EmlenInd<-pivot_longer( #makes it a frequency to rep after
  Emlen_IndData,
  cols=c("7.5","22.5","37.5","52.5","67.5","82.5","97.5","112.5","127.5",
         "142.5","157.5","172.5","187.5","202.5","217.5","232.5","247.5",
         "262.5","277.5","292.5","307.5","322.5","337.5","352.5"),
  names_to="sector",
  values_to="count")
```

Lets save the all the numbers in one variable to make a new table with the

```{r uniqueIdent}
uniqueValues_ID<-unique(datalong_EmlenInd$Identificator)
```

This is a really important piece of code because I'm going to store the statistics results for each individual experiment

```{r Results_df}
#| warning: false
results_df <- data.frame(Identificator = uniqueValues_ID,   #create an empty dataframe to store results
                         test_statistic = numeric(length(uniqueValues_ID)),
                         p_value = numeric(length(uniqueValues_ID)),
                         Mean = numeric(length(uniqueValues_ID)),
                         Lower_CI = numeric(length(uniqueValues_ID)),
                         Upper_CI = numeric(length(uniqueValues_ID)))

# Loop through unique identifiers
for (i in uniqueValues_ID) {
  subset_data <- subset(datalong_EmlenInd, Identificator == i) #subsets data for each identificator/each entry in the database
  IndData <- as.data.frame(as.numeric(unlist(subset_data)))
  IndData <- na.omit(IndData)
  longdata <- as.numeric(rep(subset_data$sector, times = subset_data$count)) #repeats the degrees the times we counted already
  conf_interval <- confidence_interval(longdata, conf.level = 0.95, axial = FALSE)
  longdata <- deg2rad(longdata)  # Convert to radians
  rayleigh_test <- rayleigh.test(longdata)#performs rayleigh test for each entry in the database
  test_statistic <- rayleigh_test$statistic
  p_value <- rayleigh_test$p.value
  MeanDir<- mean.circular(longdata)
  
  
  # Convert the mean direction from radians to degrees and correct negative values
  MeanDir_deg <- rad2deg(MeanDir)  # Convert to degrees
  if (MeanDir_deg < 0) {
    MeanDir_deg <- 360 + MeanDir_deg  # Wrap around negative values
  }
  
  # Assign results to the correct rows
  row_index <- which(results_df$Identificator == i)
  results_df$test_statistic[row_index] <- test_statistic
  results_df$p_value[row_index] <- p_value
  results_df$Mean[row_index]<- MeanDir_deg
  results_df$Lower_CI[row_index]<- conf_interval$conf.interval[1]
  results_df$Upper_CI[row_index]<- conf_interval$conf.interval[2]
}

```

Before merging anything, there are some negative values and some values above 360, we can adjust them with the function defined earlier:

```{r results360adj}
results_df <- as.data.frame(results_df %>% mutate_all(adjust_360))
```

We have the results per identificator. Now we merge both tables to have all the data associated to each one of the rings

```{r mergedEmlen}
mergedEmlen<-merge(results_df, Emlen_IndData, by = "Identificator") #merge both dataframes by identificator
```

To check unique values and how many data points a ring has to perform a paired test later

```{r uniqueValues_Ring}
uniqueValues_Ring<-unique(mergedEmlen$Ring)
length(uniqueValues_Ring)
```

to see how many times a ring occours in the dataframe (this is because we need to have the same size if we want to do a paired test)

```{r occurrences}
occurrences <- mergedEmlen %>% count(Ring) 
print(occurrences)
```

Now we can choose the columns to make the tests

```{r EmlenData_ForTest}
EmlenData_ForTest<- dplyr::select(mergedEmlen, c("Identificator",
                                                 "test_statistic","p_value", 
                                                 "Mean", "Lower_CI", "Upper_CI",
                                                 "Species", "Treatment","Ring",
                                                 "BreedingDistribution", "Week"))
```

```{r set_y}
EmlenData_ForTest$y<-0.95
```

And now divide them for treatment

```{r TreatmentSplit}
Emlen_capture<-filter(EmlenData_ForTest, Treatment=="capture") #just capture
Emlen_control<-filter(EmlenData_ForTest, Treatment=="control") #just control
Emlen_treatment<-filter(EmlenData_ForTest, Treatment=="treatment") #just 24h treatment

```

Plot the mean of all individuals in the treatments

```{r simple_plots}
plot(as.circular(Emlen_capture$Mean, type="angles", units="degrees", template="geographic", zero=0))
r_cap <- rho.circular(Emlen_capture$Mean, na.rm = FALSE)
arrows.circular(mean.circular(Emlen_capture$Mean), y=r_cap, length=0.1)
conf_interval_cap <- confidence_interval(Emlen_capture$Mean, conf.level = 0.95, axial = FALSE)

plot(as.circular(Emlen_control$Mean, type="angles", units="degrees", template="geographic", zero=0))
r_con <- rho.circular(Emlen_control$Mean, na.rm = FALSE)
arrows.circular(mean.circular(Emlen_control$Mean), y=r_con, length=0.1)

plot(as.circular(Emlen_treatment$Mean, type="angles", units="degrees", template="geographic", zero=0))
r_tre <- rho.circular(Emlen_treatment$Mean, na.rm = FALSE)
arrows.circular(mean.circular(Emlen_treatment$Mean), y=r_tre, length=0.1)

```

To calculate the mean for each species we can do the same as we did before for each individual but with other method

```{r Results_treat}
#| warning: false

EmlenData_sp_Mean<- dplyr::select(mergedEmlen, c("Identificator",
                                                 "Mean", "Species", "Treatment","Ring",
                                                 "BreedingDistribution", "Week"))
Results_treat <- EmlenData_sp_Mean %>%
  group_by(Treatment, Species) %>%
  summarize(
    Lower_CI = if (n() > 1) confidence_interval(Mean, conf.level = 0.95, axial = FALSE)$conf.interval[1] else NA,
    Upper_CI = if (n() > 1) confidence_interval(Mean, conf.level = 0.95, axial = FALSE)$conf.interval[2] else NA,
    test_statistic = rayleigh_test(deg2rad(Mean))$statistic,
    p_value = rayleigh_test(deg2rad(Mean))$p.value,
    Mean = rad2deg(mean.circular(deg2rad(Mean)))
  )

View(Results_treat)

```

To make the negative values positive, I added 360. The values that are above 360 I substracted 360

```{r res_treatAdj}
Results_treat <- as.data.frame(Results_treat %>% mutate_all(adjust_360))
```

To plot each species per treatment with the mean value for the species and the confidence intervals for each species

```{r AllInd_sp}
ggplot(aes(x = Mean, y=y, colour=Species), data=EmlenData_ForTest) +
  geom_point(size = 1.8, alpha=1, shape=21, stroke = 0.5, colour = "black", 
             aes(fill=factor(Species)))+
  coord_polar() +
  scale_x_continuous("", limits=c(0,360),
                      breaks=seq(0,360-0.001,by=90),
                      labels=c("N","E","S","W")) +
         scale_y_continuous("",limits=c(0,1), breaks=1)+
  geom_hline(yintercept=1)+
  #theme_minimal()+
  geom_segment(data=Results_treat, 
               mapping=aes(y = 0, xend = Mean, yend = test_statistic),
                  arrow = arrow(type="closed",ends="last",length=unit(2,"mm")), color="black", size=0.7)+
  geom_vline(data=Results_treat, aes(xintercept = Lower_CI), linetype="dashed")+
  geom_vline(data=Results_treat, aes(xintercept = Upper_CI), linetype="dashed")+
  theme(panel.background = element_rect(fill = NA),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())+
  ggtitle("Circular Plot") +  
  ylab("")+ 
  xlab("")+
  facet_wrap(Species~Treatment)

```

To plot each individual ring witht the mean value and the confidence intervals

```{r AllInds}
# ggplot(aes(x = Mean, y=y, colour=Species), data=EmlenData_ForTest) +
#   geom_point(size = 3, alpha=1/2)+
#   coord_polar() +
#   scale_x_continuous("", limits=c(0,360),
#                       breaks=seq(0,360-0.001,by=90),
#                       labels=c("N","E","S","W")) +
#          scale_y_continuous("",limits=c(0,1), breaks=1)+
#   geom_hline(yintercept=1)+
#   theme(panel.background = element_rect(fill = NA),
#         axis.title.y = element_blank(),
#         axis.text.y = element_blank(),
#         axis.ticks.y = element_blank())+
#   ggtitle("Circular Plot") +  
#   ylab("")+ 
#   xlab("")+
#   facet_wrap(vars(Ring))
# 
# 
# ggplot(aes(x = Mean, y=y, colour=Species), data=EmlenData_ForTest) +
#   geom_point(size = 1.8, alpha=1, shape=21, stroke = 0.5, colour = "black", 
#              aes(fill=factor(Species)))+
#   coord_polar() +
#   scale_x_continuous("", limits=c(0,360),
#                       breaks=seq(0,360-0.001,by=90),
#                       labels=c("N","E","S","W")) +
#          scale_y_continuous("",limits=c(0,1), breaks=1)+
#   geom_hline(yintercept=1)+
#   #theme_minimal()+
#   geom_segment(data=results_df, 
#                mapping=aes(y = 0, xend = Mean, yend = test_statistic),
#                   arrow = arrow(type="closed",ends="last",length=unit(2,"mm")), color="black", size=0.7)+
#   geom_vline(data=results_df, aes(xintercept = Lower_CI))+
#   geom_vline(data=results_df, aes(xintercept = Upper_CI))+
#   theme(panel.background = element_rect(fill = NA),
#         axis.title.y = element_blank(),
#         axis.text.y = element_blank(),
#         axis.ticks.y = element_blank())+
#   ggtitle("Circular Plot") +  
#   ylab("")+ 
#   xlab("")+
#   facet_wrap(vars(Ring))
```

### Tests

#### Watson test

To test whether the mean values for each group differ between groups we can do a watson test. R help documentation says:\
Watson.williams.test assumptions are that: (1) the samples are drawn from populations with a von Mises distribution; (2) the parameter of concentration has the same value in all populations; (3) this parameter is sufficiently large (i.e. \> 1).

If the assumptions are not met in the data set it is needed to do a watson.wheeler.test

```{r}
#| warning: false
EmlenData_ForTest$Mean<-as.circular(EmlenData_ForTest$Mean, units='degrees', template='geographics', modulo="2pi")

watson.wheeler.test(Mean ~ BreedingDistribution, EmlenData_ForTest)
```

#### Hotelling paired test

First lets make a subset for each treatment and change the column names to something distinguishable

```{r treat_subset}
setnames(Emlen_capture, old = c("test_statistic", "p_value", "Mean", 
                                "Lower_CI", "Upper_CI"),
         new = c("test_statistic_capture", "p_value_capture", "Mean_capture",
                 "Lower_CI_capture", "Upper_CI_capture"), skip_absent=TRUE)
Emlen_capture<-dplyr::select(Emlen_capture, -c("Treatment", "Identificator"))

setnames(Emlen_control, old = c("test_statistic", "p_value", "Mean", 
                                "Lower_CI", "Upper_CI"),
         new = c("test_statistic_control", "p_value_control", "Mean_control",
                 "Lower_CI_control", "Upper_CI_control"), skip_absent=TRUE)
Emlen_control<-dplyr::select(Emlen_control, -c("Treatment", "Identificator"))

setnames(Emlen_treatment, old = c("test_statistic", "p_value", "Mean", 
                                "Lower_CI", "Upper_CI"),
         new = c("test_statistic_treatment", "p_value_treatment", 
                 "Mean_treatment", "Lower_CI_treatment", "Upper_CI_treatment"),
         skip_absent=TRUE)
Emlen_treatment<-dplyr::select(Emlen_treatment, -c("Treatment", "Identificator"))
```

Now we can intersect all of the rings and make a table suitable for the hotelling test

```{r common_ids}
common_ids <- Reduce(intersect, list(Emlen_capture$Ring, Emlen_control$Ring, Emlen_treatment$Ring))
```

To retrieve the Rings that have capture, control and treatment experiments

```{r Emlen_ID}
Emlen_capture_ID <- Emlen_capture[Emlen_capture$Ring %in% common_ids, ]
Emlen_control_ID <- Emlen_control[Emlen_control$Ring %in% common_ids, ]
Emlen_treatment_ID <- Emlen_treatment[Emlen_treatment$Ring %in% common_ids, ]
```

And to merge a database for making the Hotelling test

```{r hotelling_db}
Emlen_hotelling <- merge(Emlen_capture_ID, Emlen_control_ID, by="Ring")




%>%
              merge(Emlen_treatment_ID, by="Ring")
```

ENCONTRAR COMO UNIR LAS TABLAS PARA HACER EL HOTTELING

HACER EL CAMBIO ANGULAR ENTRE CONTROL Y CAPTURE, CONTROL Y TREATMENT Y CAPTURE Y TREATMENT

PLOTEAR EL CAMBIO ANGULAR

GLMER PARA:

counts \~ radians + (1\|Ring) + (1\|Species)

counts \~ radians \* Treatment + (1\|Ring) + (1\|Species)

counts \~ radians \* Treatment \* BreedingDistribution + (1\|Ring) + (1\|Species)

ARMAR EL QUARTO PARA STF. LOS MODELOS DE STF VAN CON DAY COMO FACTOR
